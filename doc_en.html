<div class="pedagogic paper" key="exercise_description_demo_bernoulli_1">
 <!--{type="ex_title"}-->
 <p> <span class="txtwrap slide" style="padding-top:15px"> <img src="./img/demo_bernoulli_1.png"> </span> </p>
 <p> The powers of two are bound from above by the values of the exponent, i.e. that
  <!--{type="expr" input="(pow 2 n) >= (plus n 1)"}-->, as is illustrated in the graph opposite. </p>
 <center>
  <table class="borderblue">
   <colgroup>
    <col width="60">
    <col width="60">
    <col width="60">
   </colgroup>
   <tbody>
    <tr>
     <td><span class="bold">
       <!--{type="expr" input="n"}--></span></td>
     <td><span class="bold">
       <!--{type="expr" input="n+1"}--></span></td>
     <td><span class="bold">
       <!--{type="expr" input="2^n"}--></span></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="0"}--></td>
     <td>
      <!--{type="expr" input="1"}--></td>
     <td>
      <!--{type="expr" input="1"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="1"}--></td>
     <td>
      <!--{type="expr" input="2"}--></td>
     <td>
      <!--{type="expr" input="2"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="2"}--></td>
     <td>
      <!--{type="expr" input="3"}--></td>
     <td>
      <!--{type="expr" input="4"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="3"}--></td>
     <td>
      <!--{type="expr" input="4"}--></td>
     <td>
      <!--{type="expr" input="8"}--></td>
    </tr>
    <tr>
     <td>...</td>
     <td>...</td>
     <td>...</td>
    </tr>
   </tbody>
  </table>
 </center>
 <p> This inequality is a specific example of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Bernoulli%27s_inequality" target="_blank">Bernoulli’s inequalities</a></span>, demonstrated in the following exercise: </p>
 <p>
  <!--{type="exercise" input="demo_bernoulli_2"}--> </p>
 <p> <span class="light-bulb">ń</span> Use reasoning <span class="buttontheo">by induction</span>. </p>
</div>
<div class="pedagogic paper" key="exercise_description_demo_bernoulli_2">
 <!--{type="ex_title"}-->
 <p> These inequalities generalize the result see previously. They are attributed to the Swiss mathematician, <span class="exturl"><a href="https://en.wikipedia.org/wiki/Jacob_Bernoulli" target="_blank">Jacques Bernoulli</a></span>. We call them the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Bernoulli%27s_inequality" target="_blank">Bernoulli’s inequality</a></span>. </p>
 <p> <span class="light-bulb">ń</span> Use reasoning by induction. </p>
</div>
<div class="pedagogic paper" key="exercise_description_ineq_ex_8">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_abs_peirce">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_01">
 <!--{type="ex_title"}-->
 <p>We can demonstrate that disjunction is distributive <span class="stress">over conjunction</span>.</p>
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_02">
 <!--{type="ex_title"}-->
 <p> It can be shown that conjunction is distributive <span class="stress">over disjunction</span>. </p>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_06">
 <!--{type="ex_title"}-->
 <p> In this exercise, the universe of elements is made up of all <span class="exturl"><a href="https://en.wikipedia.org/wiki/Natural_number" target="_blank">natural numbers</a></span>. </p>
 <p> The formulae are the <span class="stress">propositions defined on ℕ</span>, and the elements are the integers. </p>
 <p> Note "
  <!--{type="prop" sci="true" input="forall (x:Nvar), app_prop U P x"}-->" and "
  <!--{type="prop" sci="true" input="exists (x:Nvar), app_prop U P x"}-->" quantifications on ℕ. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_08">
 <!--{type="ex_title"}-->
 <a href="https://en.wikipedia.org/wiki/The_School_of_Athens" target="_blank"><img class="txtwrap" src="./img/aristote-raphael-ecole-d-athenes.jpg" height="30%" width="30%"></a>
 <p> The <span class="exturl"><a href="https://en.wikipedia.org/wiki/Syllogism" target="_blank">syllogism</a></span> is a reasoning formalized in the 4<span class="sup">th</span> Century BC in <span class="exturl"><a href="https://en.wikipedia.org/wiki/Ancient_Greece" target="_blank">Ancient Greece</a></span> par <span class="exturl"><a href="https://en.wikipedia.org/wiki/Aristotle" target="_blank">Aristotle</a></span> who considered it a fundamental element of logic and reasoning. </p>
 <p> The syllogism served, and continues to serve, as a logical foundation to <span class="exturl"><a href="https://en.wikipedia.org/wiki/Law" target="_blank">Legislation</a></span>, born in <span class="exturl"><a href="https://en.wikipedia.org/wiki/Ancient_Rome#Republic" target="_blank">Ancient Rome</a></span>. It is the scheme on which legal judgements are constructed in western tradition. </p>
 <p>Let’s imagine, for example that a tribunal must respond to the question "Is Socrates mortal?". The answer lies in the discovery of un attribute "man". Let’s lay out the definitions:</p>
 <table class="slide">
  <colgroup>
   <col width="150">
   <col width="30">
   <col width="150">
  </colgroup>
  <tbody>
   <tr>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">Minor term</td>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">A</td>
    <td style="padding-top: 10px; border-bottom: 1px solid whitesmoke;">Socrates</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">Middle term</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">B</td>
    <td style="border-bottom: 1px solid whitesmoke;">being a man</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke;">Major term</td>
    <td style="border-right: 1px solid whitesmoke;">C</td>
    <td>being mortal</td>
   </tr>
  </tbody>
 </table>
 <p>It is therefore judged following the schema below:</p>
 <table class="slide">
  <colgroup>
   <col width="200">
   <col width="90">
   <col width="250">
   <col width="250">
  </colgroup>
  <tbody>
   <tr>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Major premise</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">B ⇒ C</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;"> All men are mortals. (man ⇒ mortal)</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">The rule of law</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Minor premise</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ B</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Socrates is a man.</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;"> The legal qualification of the minor term (Socrates), which is subject to the proceedings.</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Conclusion</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ C</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Socrates is mortal.</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">The judgement</td>
   </tr>
  </tbody>
 </table>
 <p> The challenge the process presents is therefore qualifying (or not) the minor term (the accused) as a middle term. Learning the spirit of the laws (the meaning given to the laws) allows the judge to decide, by studying <span class="exturl"><a href="https://en.wikipedia.org/wiki/Case_law" target="_blank">case law</a></span> that is the set of court decisions. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_12">
 <!--{type="ex_title"}-->
 <p>This implication is only true in classical logic. This poses no problem to its use in electronics : either the current flows or it doesn’t.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_13">
 <!--{type="ex_title"}-->
 <a href="./img/Diopsis.jpg" target="_blank"><img class="txtwrap" src="./img/Diopsis.jpg" height="30%" width="30%"></a>
 <p>The <span class="exturl"><a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a></span> are formulae that allow us to calculate the negation of any mathematical proposition.</p>
 <p>We can demonstrate that the negation of a disjunction is the conjunction of the negations of the operands.</p>
 <p>These laws are used in IT within the conception of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Logic_gate" target="_blank">logical functions</a></span> and and their physical materialization, notably in the form of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Integrated_circuit">integrated circuits</a></span>.</p>
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_14">
 <!--{type="ex_title"}-->
 <p> A binary <span class="exturl"><a href="https://en.wikipedia.org/wiki/Operator_(mathematics)" target="_blank">operator</a></span> noted, for example, ★, is <span class="exturl"><a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">associative</a></span> if, whatever the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Operand" target="_blank">operands</a></span> a b c : </p>
 <p>a ★ (b ★ c) = (a ★ b) ★ c</p>
 <p>Since their position is not important; brackets can be omitted. Hence the value above is written a ★ b ★ c. It is, for example, the associativity of addition that allows us to write 3 + 5 + 8 without the need for brackets.</p>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
 <div class="slide">
  <p> <span class="light-bulb">ń</span> By definition, an equivalence is demonstrated by demonstrating two implications. Definition of <span class="buttontheo">equivalence</span> is chosen to demonstrate
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_16">
 <!--{type="ex_title"}-->
 <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">Contraposition</a></span>, or modus tollens, consists of demonstrating that A implies B, by demonstrating that the negation of B implies the negation of A: if B didn’t stand, A wouldn’t stand, therefore if A stands, then B stands. </p>
 <p> This reasoning only applies within <span class="stress">classical logic</span>. However, the inverse implication,
  <!--{type="prop" sci="true" input="(A -> B) -> (~B -> ~A)"}--> is true in constructive logic, as demonstrated in the following exercise. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_17">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
 <p>This way, the implication is demonstrated using constructive logic.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_27">
 <!--{type="ex_title"}-->
 <p>Associativity of conjunction is demonstrated in a similar way to associativity of disjunction.</p>
 <div class="slide">
  <p> <span class="light-bulb">ń</span> Demonstrating disjunction of
   <!--{type="prop" sci="true" input="or A B"}--> requires <span class="stress">choosing</span> between the demonstration of A or B. </p>
  <p>The method consists of choosing as late as possible, and then exploiting all hypotheses (by disjunction of cases) in order to obtain the maximum amount of information that allows us to make the choice.</p>
 </div>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_31">
 <!--{type="ex_title"}-->
 <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">Ad absurdium reasoning</a></span> consists of demonstrating a proposition A by showing that if its negation, ¬ A, is true, then we obtain a contradiction: </p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Ad absurdium reasoning</span>
     <!--{type="prop" sci="true" input="forall A:Prop, ((~(~A)) -> A)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p> In effect,
  <!--{type="prop" sci="true" input="~(~A)"}--> can be re-written as
  <!--{type="prop" sci="true" input="(~A -> False)"}--> by definition of negation. Ad absurdium reasoning is therefore a law of elimination of double negation. </p>
 <p>This exercise demonstrates that the excluded middle involves ad absurdium reasoning.</p>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
 <p>Reciprocal implication is demonstrated in the exercise below. As a result, ad absurdium reasoning is equivalent to the excluded middle, and is therefore not acknowledged by constructive logic:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_48"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_32">
 <!--{type="ex_title"}-->
 <p>We can demonstrate that disjunction of two negations is the negation of conjunction of the propositions. This implication is made with constructive logic, but not the inverse implication, as shown in the next exercise.</p>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_33">
 <!--{type="ex_title"}-->
 <p>It can be demonstrated that disjunction is distributive <span class="stress">over implication</span>.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_34">
 <!--{type="ex_title"}-->
 <p>It can be demonstrated that conjunction is "half distributive" over implication.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_peirce_abs_te">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_peirce_law">
 <!--{type="ex_title"}-->
 <a href="https://en.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank"><img class="txtwrap" src="./img/peirce.jpg" height="30%" width="30%"></a>
 <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Peirce%27s_law" target="_blank">Peirce's law</a></span> is true in classical logic. <span class="exturl"><a href="https://en.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank">Charles Sanders Peirce</a></span> was an American philosopher, logician and mathematician. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_tuto_01">
 <!--{type="ex_title"}-->
 <p>What can be deduced from the conjunction "A ∧ B"?</p>
 <p>Follow the instructions to solve the problem.</p>
 <p> <span class="light-bulb">A</span>Each exercise has a conclusion and an initial context, which lays out the variables and the hypothesis. </p>
 <p> <span class="light-bulb">A</span>The conclusion and the hypothesis are <span class="exturl"><a href="https://en.wikipedia.org/wiki/Statement_(logic)" target="_blank">mathematical statements</a></span>. The objective is to come up with a series of statements, which make up the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Mathematical_proof" target="_blank">proof</a></span> that the conclusion is true. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_21">
 <!--{type="ex_title"}-->
 <p>In Scotland, a private club has the following rules:</p>
 <ul>
  <li>Every non-Scottish member wears red socks.</li>
  <li>Every member wears a kilt or doesn't wear red socks.</li>
  <li>The married members don't go out on Sunday.</li>
  <li>A member goes out on Sunday if and only if he is Scottish.</li>
  <li>Every member who wears a kilt is Scottish and married.</li>
  <li>Every Scottish member wears a kilt.</li>
 </ul>
 <p>Now, we show that these rules are so strict that no one can be accepted!</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_03">
 <!--{type="ex_title"}-->
 <p>It is demonstrated that the complement of a union is the intersection of the complements.</p>
 <p>We call this formula a De Morgan law by analogy with the De Morgan laws established for conjunctions and disjunctions. There are indeed similarities between the properties (distributivity, associativity, commutativity) of the union, of the intersection and of the complement, and those of the disjunction, the conjunction and the negation respectively.</p>
 <p>This is a consequence of the definition of the set operators: belonging to a union of two sets is the disjunction of membership to each of the two sets.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_07">
 <!--{type="ex_title"}-->
 <p>The demonstration of the distributivity of the existential quantifier over disjunction is concluded.</p>
 <p> <span class="light-bulb">ń</span> It is necessary to generate the unknown witness variable <span class="button" style="font-family: 'Times New Roman'; font-weight: bold; font-size: 14px; padding: 3px;">x?</span> within the scope (or a sub-scope) that contains the variable(s) allowing us to figure out this unknown witness value. In this example, the witness value is provided within the scopes created <span class="buttontheo">by using disjunction of cases</span>. This reasoning is therefore used before reasoning <span class="buttontheo">by construction</span>. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_09">
 <!--{type="ex_title"}-->
 <p>It can be shown that the empty set <span class="exturl"><a href="https://en.wikipedia.org/wiki/Subset" target="_blank">subset</a></span> of any set.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_easy_08">
 <!--{type="ex_title"}-->
 <p>What is the logical negation of a universal quantification?</p>
 <p>The negation of "for every x, F (x)" is not "for every x, not F (x)", but "there exists x such that F (x)".</p>
 <p>Here, one of the two implications is demonstrated.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_easy_09">
 <!--{type="ex_title"}-->
 <p>What is the logical negation of an existential quantification?</p>
 <p>The negation of "there exists x, such that F (x)" is not "there exists x, such that not F (x)", but “for every value x, not F (x)".</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_01">
 <!--{type="ex_title"}-->
 <p>The binary relation on ℕ "is less than", noted
  <!--{type="prop" sci="true" input="app_rel rel_le x y"}-->, is defined in these exercises by an existential formula:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Is less than</span>
     <!--{type="prop" sci="true" input="forall (x y:Nvar), equiv (app_rel rel_le x y) (exists (z:Nvar),y=x+z)"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>We can demonstrate that addition is increasing for this relation.</p>
 <p>"Is less than" exercises:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_02"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_03"}--></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_02">
 <!--{type="ex_title"}-->
 <p>"Is less than" Exercises:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_01"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_03"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_04">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p>There are two kinds of people on a mysterious island. There are so-called honestants who always speak the truth, and the others are swindlecants who always lie.</p>
 <p> Show that if <span style="font-weight: bold">a</span> and <span style="font-weight: bold">b</span> are two people on the island and that if <span style="font-weight: bold">a</span> says that <span style="font-weight: bold">b</span> is lying, at least one of the two is a swindlecant. </p>
 <p> <span class="light-bulb">ń</span> The axiom <span class="buttontheo">speaking the truth or lying</span> is used to generate two cases: either <span style="font-weight: bold">a</span> is honestant, or <span style="font-weight: bold">a</span> is swindlecant. The theory "Honestants and Swindlecants" is made up of the following axioms: </p>
 <table class="slide">
  <colgroup>
   <col width="25%">
   <col width="75%">
  </colgroup>
  <tbody>
   <tr>
   </tr>
   <tr>
    <td style="vertical-align: top"><span class="def" style="padding-top: 20px">Honestants and Swindlecants</span></td>
    <td style="padding-top: 24px;">
     <!--{type="prop" input="forall (a:gbmember), (or (is_good a) (is_bad a))"}--></td>
   </tr>
   <tr>
    <td style="vertical-align: top; padding-top: 8px"><span class="def">The truth told by the honestant</span></td>
    <td>
     <!--{type="prop" style="padding-top: 20px" input="forall (a:gbmember) (P:Prop), (is_good a) -> (say a P) -> P"}--></td>
   </tr>
   <tr>
    <td style="vertical-align: top; padding-top: 8px"><span class="def">The lie told by the swindlecant</span></td>
    <td>
     <!--{type="prop" input="forall (a:gbmember) (P:Prop), (is_bad a) -> (say a P) -> (~ P)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_05">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p> Show that if <span style="font-weight: bold">a</span> says that <span style="font-weight: bold">a</span> and <span style="font-weight: bold">b</span> are both swindlecants, then <span style="font-weight: bold">a</span> is a swindlecant. </p>
 <p> "Honestants and Swindlecants" exercises: </p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_06">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p> Show that if <span style="font-weight: bold">a</span> says
  <!--{type="expr" input="False"}--> then he is a swindlecant. </p>
 <p></p> Exercises "Honestants and Swindlecants" :
 <p></p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_07">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p>Show that a person living on the island cannot say that he himself is a swindlecant.</p>
 <p></p> Exercises "Honestants and Swindlecants" :
 <p></p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_13">
 <!--{type="ex_title"}-->
 <!--  <a href="https://fr.wikipedia.org/wiki/Principe_des_tiroirs" target="_blank"><img class="txtwrap" src="http://img.1.im6.fr/03E8000007913469-photo-dressing-tiroir-casiers-chaussettes.jpg" height="30%" width="30%"></img></a> -->
 <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 2 Relations et fonctions</a></span></span>
 <p> In 1834, the German mathematician <span class="exturl"><a href="https://en.wikipedia.org/wiki/Peter_Gustav_Lejeune_Dirichlet" target="_blank">Johann Dirichlet</a></span> announced the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank">pigeonhole principle</a></span>, which applies to the case in which n pigeons occupy m holes: </p>
 <p style="align: center; font-style: italic">If n &gt; m, then at least one hole must contain strictly more than one pigeon.</p>
 <p> In other words, by <span class="exturl"><a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">contraposition</a></span>, if each hole contains at the most one pigeon, then n &lt;= m. </p>
 <p> Let’s consider <span class="stress">the storage function</span> of n+1 pigeons, indexed from 0 to n, in holes: this function takes the index of a pigeon as argument, and returns an index of a hole. The assumption that a hole contains at the most one pigeon, translates into f being an <span class="stress">injective function</span> (the fiber of a hole has at most one element). Furthermore, given that by hypothesis, m holes contain the pigeons, there is one pigeon, indexed x, such that f(x)=m. </p>
 <p>Demonstrating the pigeonhole principle therefore consists of demonstrating that if the function f is injective over the set [0 ... n], then there is one pigeon numbered x, such that its hole, f(x), is greater or equal to n.</p>
 <p>To simplify this, we can reason with a notion stronger than injectivity and consider strictly increasing functions:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td>
     <!--{type="prop" sci="true" input=" forall (n:Nvar) (f:NvarFun), equiv (FFMono n f) (forall (x y:Nvar), ExprLT x y -> ExprLT y n -> ExprLT (app_fun f x) (app_fun f y))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>Opposite, it is demonstrated that the strict increase is a stronger condition than injectivity over [0 ... n], which is expressed here in the following way :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td>
     <!--{type="prop" sci="true" input="forall (n:Nvar) (f:NvarFun), equiv (FFInj n f) (forall (x y:Nvar), ExprLT x n -> ExprLT y n -> app_fun f x = app_fun f y -> nvar x = nvar y)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>The pigeonhole principle is demonstrated in the following exercise, following the strict increase of the storage function.</p>
 <p> </p>
 <h3>Solution</h3>
 <p> <span class="light-bulb">ń</span> Use a case base reasoning with the help of
  <!--{type="tag" input="2"}-->. </p>
 <p>Use theorems below on equalities and inequalities:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Symmetry</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (x=y) (y=x))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (x<>y) (y<>x))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Inequality rewritings</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGT x y) (ExprLT y x))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGTEQ x y) (ExprLTEQ y x))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Strict inequality</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (ExprGT x y) -> (x <> y)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (ExprLT x y) -> (x <> y)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_14">
 <!--{type="ex_title"}-->
 <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 2 Relations et fonctions</a></span></span>
 <p>The pigeonhole principle is presented in the previous exercise. It is do with demonstrating that if a function is injective over [0 .. n], then there exists x in [0 ... n] such that f(x) ≥ n.</p>
 <p> We have previously demonstrated that a sufficient condition for being injective over [0 ... n] is to be strictly increasing over [0 ... n]. </p>
 <p>The pigeonhole principle is demonstrated opposite, using a strictly increasing function as the hypothesis.</p>
 <div class="slide">
  <p> <span class="light-bulb">ń</span> Use reasoning by recurrence over n. </p>
 </div>
 <p>The theorems below enable us to transform an inequality between two integers to a strcit inequality, and vice versa:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Transition to the next integer</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGT x y) (ExprGTEQ x (y+1)))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGTEQ x y) (ExprGT (x+1) y))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>The different forms of transitivity of comparison operators also enable us to introduce or eliminate strict inequalities from inequalities, and vice versa:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Transitivity</span>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGT y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGT y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGTEQ y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGTEQ y z) -> (ExprGTEQ x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGTEQ y z) -> (ExprGTEQ x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGT y z) -> (ExprGTEQ x z)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_27">
 <!--{type="ex_title"}-->
 <p>This result is available in the other exercises, as <span class="buttontheo">set characterization</span> of a transitive relation.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_31">
 <!--{type="ex_title"}-->
 <p> <span class="light-bulb">ń</span> Use the characterization of a transitive relation, and the conservation of inclusion by composition. </p>
 <p> <span class="light-bulb">A</span>Selecting a term in a proposition with the cursor allows you to replace it with another term; it is therefore necessary to prove that it is equal to the original term. </p>
 <h3>Also see</h3>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_27"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_47"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_47">
 <!--{type="ex_title"}-->
 <p>Composition conserves inclusion.</p>
 <p> This result is available in other exercises, as "combination by <span class="buttontheo">composition</span>" rule. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_48">
 <!--{type="ex_title"}-->
 <p>The law of excluded middle is demonstrated by assuming ad absurdium rule (double negation elimination).</p>
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_71">
 <!--{type="ex_title"}-->
 <p>Mrs. Muddled has three children, Alice, Bill, and Carl.</p>
 <p>When asked her 3 children's ages, Mrs. Muddled said that Alice is the youngest unless Bill is, and that if Carl isn't the youngest then Alice is the oldest.</p>
 <p> Who is the oldest and who is the youngest?</p>
 <h3>Theory</h3>
 <p>Information given by Mrs. Muddled is provided by assumptions <span class="propid">4</span> et <span class="propid">5</span></p>
 <p>There’s some implicit meaning in the superlative words “youngest” and “oldest” provided by the following rules : </p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Antonymy</span>
     <!--{type="prop" input="forall (x:Child), (Youngest x) -> (~(Oldest x))"}--><br><br>
     <!--{type="prop" input="forall (x:Child), (Oldest x) -> (~(Youngest x))"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>Finally, “youngest” and “oldest” are opposites. Since there is more than one child, no one can be both.</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Uniqueness</span>
     <!--{type="prop" input="forall (x y:Child), (x <> y) -> (Youngest x) -> (~(Youngest y))"}--><br><br>
     <!--{type="prop" input="forall (x y:Child), (x <> y) -> (Oldest x) -> (~(Oldest y))"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_72">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_sigma_ex_15">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_sigma_ex_16">
 <!--{type="ex_title"}-->
</div>
<div key="help_description_icon_exercises_check">
 <!--TODO-->
</div>
<div key="help_description_icon_exercises_difficulty">
 <!--TODO-->
</div>
<div key="help_description_icon_exercises_lighbulb">
 <!--TODO-->
</div>
<div key="help_description_icon_exercises_lock">
 <!--TODO-->
</div>
<div key="help_description_icon_trophy_all">
 <!--TODO-->
</div>
<div key="help_description_icon_trophy_diagnostic">
 <!--TODO-->
</div>
<div key="help_description_icon_trophy_tutorial">
 <!--TODO-->
</div>
<div key="help_description_icon_trophy_unavoidable">
 <!--TODO-->
</div>
<div key="help_description_shortcut_browsing_left_scope">
 <!--TODO-->
</div>
<div key="help_description_shortcut_browsing_lower_prop">
 <!--TODO-->
</div>
<div key="help_description_shortcut_browsing_open_scope">
 <!--TODO-->
</div>
<div key="help_description_shortcut_browsing_redo">
 <!--TODO-->
</div>
<div key="help_description_shortcut_browsing_right_scope">
 <!--TODO-->
</div>
<div key="help_description_shortcut_browsing_undo">
 <!--TODO-->
</div>
<div key="help_description_shortcut_browsing_upper_prop">
 <!--TODO-->
</div>
<div key="help_description_shortcut_commutativity_commut_left">
 <!--TODO-->
</div>
<div key="help_description_shortcut_commutativity_commut_mode">
 <!--TODO-->
</div>
<div key="help_description_shortcut_commutativity_commut_right">
 <!--TODO-->
</div>
<div key="help_description_shortcut_commutativity_commut_shift_left">
 <!--TODO-->
</div>
<div key="help_description_shortcut_commutativity_commut_shift_right">
 <!--TODO-->
</div>
<div key="help_description_shortcut_commutativity_enter_commut">
 <!--TODO-->
</div>
<div key="help_description_shortcut_commutativity_esc_commut">
 <!--TODO-->
</div>
<div key="help_description_shortcut_evar_enter_evar">
 <!--TODO-->
</div>
<div key="help_description_shortcut_evar_esc_evar">
 <!--TODO-->
</div>
<div key="help_description_shortcut_evar_evar_left">
 <!--TODO-->
</div>
<div key="help_description_shortcut_evar_evar_mode">
 <!--TODO-->
</div>
<div key="help_description_shortcut_evar_evar_right">
 <!--TODO-->
</div>
<div key="help_description_shortcut_proof_context">
 <!--TODO-->
</div>
<div key="help_description_shortcut_proof_deduce">
 <!--TODO-->
</div>
<div key="help_description_shortcut_proof_enter">
 <!--TODO-->
</div>
<div key="help_description_shortcut_proof_justify">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_enter_select">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_esc_select">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_group_select">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_select_down">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_select_left">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_select_mode">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_select_right">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_select_shift_left">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_select_shift_right">
 <!--TODO-->
</div>
<div key="help_description_shortcut_selection_select_up">
 <!--TODO-->
</div>
<div key="help_description_shortcut_unification_enter_union">
 <!--TODO-->
</div>
<div key="help_description_shortcut_unification_esc_union">
 <!--TODO-->
</div>
<div key="help_description_shortcut_unification_left_union">
 <!--TODO-->
</div>
<div key="help_description_shortcut_unification_right_union">
 <!--TODO-->
</div>
<div key="help_description_shortcut_unification_union_mode">
 <!--TODO-->
</div>
<div key="help_section_description_browsing">
 <!--TODO-->
</div>
<div key="help_section_description_commutativity">
 <!--TODO-->
</div>
<div key="help_section_description_evar">
 <!--TODO-->
</div>
<div key="help_section_description_exercises">
 <!--TODO-->
</div>
<div key="help_section_description_proof">
 <!--TODO-->
</div>
<div key="help_section_description_selection">
 <!--TODO-->
</div>
<div key="help_section_description_trophy">
 <!--TODO-->
</div>
<div key="help_section_description_unification">
 <!--TODO-->
</div>
<div key="pager_account"></div>
<div class="pager" key="pager_algebra">
 <a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank"><img class="txtwrap" src="./img/Evariste_galois.jpg" height="20%" width="20%"></a>
 <p>Les <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Structure_alg%C3%A9brique" target="_blank">structures algébriques</a></span> sont les objets d'étude de ce chapitre.</p>
 <p> Au début du XIX<span class="sup">ème</span> siècle, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank">Evariste Galois</a></span> introduit le concept de <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Groupe_(math%C3%A9matiques)" target="_blank">groupe</a></span>. </p>
</div>
<div key="pager_algebra_structures"></div>
<div class="pager" key="pager_analysis">
 <a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank"><img class="txtwrap" src="./img/Augustin-Louis_Cauchy_1901.jpg" height="12%" width="12%"></a>
 <p> Au cours du 19<span class="sup">ème</span> siècle, les mathématiciens posent les bases de l’analyse des propriétés des fonctions réelles (fonctions à valeur réelle) : continutité, convergence, limite, dérivation, intégration, ... </p>
 <p></p>
 <p> En France dès le début du siècle, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank">Augustin Louis Cauchy</a></span> étudie notamment les propriétés de convergence des suites croissantes positives, introduites dans ce chapitre. En Allemagne, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Bernhard_Riemann" target="_blank">Bernhard Riemann</a></span> et <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Karl_Weierstrass" target="_blank">Karl Weierstrass</a></span> élaborent les théories de l’intégration et des limites de fonction. </p>
</div>
<div class="pager" key="pager_analysis_induction">
 <p> Le <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_r%C3%A9currence" target="_blank">raisonnement par récurrence</a></span> est un raisonnement incontournable, simple et puissant. Il permet de démontrer qu’une proposition P(n), dépendant d’un indice n, est vraie quelle que soit la valeur de l’indice, c’est à dire notamment vraie pour une infinité de valeurs de l’indice n. </p>
 <p> Par exemple, sans le raisonnement par récurrence, il faudrait une infinité de calculs (ou une très grande quantité) pour avoir la certitude (ou quasi-certitude) que la proposition “
  <!--{type="expr" input="4^n - 1"}--> est divisible par 3” est vraie quelle que soit la valeur de n, alors qu’un raisonnement par récurrence donne la certitude en quelques lignes de démonstration. </p>
</div>
<div class="pager" key="pager_analysis_limits">
 <p>La limite d’une fonction en un point ou en l’infini est introduite formellement. La méthode de calcul par composition de limites est présentée : par exemple, sous certaines conditions, la limite d’une somme est la somme des limites. Cette méthode permet de calculer la limite de n’importe quelle fonction par décomposition en fonctions élémentaires, dont on connaît les valeurs limites. </p>
</div>
<div class="pager" key="pager_analysis_series">
 <p> Une suite est une fonction de ℕ dans ℝ. On introduit ici quelques propriétés fondamentales des ces fonctions : </p>
 <ul>
  <li>croissance, décroissance</li>
  <li>majoration, minoration</li>
  <li>convergence, divergence</li>
 </ul>
</div>
<div key="pager_badges"></div>
<div key="pager_credits"></div>
<div key="pager_dashboard"></div>
<div class="custom pager" key="pager_demo_seg">
 <p>Calculus is about transforming an equality relation (or inequality), between real numbers or vectors for example. The challenge is to work out a sequence of algebraic manipulations (factorize, expand, ...) from assumption(s) to conclusion.</p>
</div>
<div class="pager" key="pager_eq_seg">
 <p>Une égalité peut se transformer, notamment à l’aide des transformations introduites dans ce chapitre :</p>
 <ul>
  <li>les opérations à gauche et à droite, qui permettent de “passer un terme de l’autre côté” en changeant son signe</li>
  <li>les combinaisons d’égalité, qui permettent typiquement de résoudre des systèmes d’équation</li>
  <li>le passage au carré, ou le passage à la racine carrée (si la valeur est positive), ...</li>
 </ul>
</div>
<div class="pager" key="pager_ineq_seg">
 <p>Les inégalités comparent deux nombres réels. Elles se transforment de manière similaire aux égalités :</p>
 <ul>
  <li>opérations à gauche et à droite</li>
  <li>combinaisons (addition, soustraction)</li>
  <li>applications de fonctions (opposé, carré, racine, …)</li>
  <li>…</li>
 </ul>
 <p>Si la transformation appliquée à gauche et à droite d’une inégalité est une fonction décroissante, le sens de l’inégalité entre les valeurs obtenues est inversé.</p>
</div>
<div class="pager" key="pager_logic">
 <p> The grammar of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Propositional_calculus" target="_blank">propositions</a></span>, and associated reasoning rules, form a logical system called <span class="exturl"><a href="https://en.wikipedia.org/wiki/Natural_deduction" target="_">natural deduction</a></span>, notably used for developing mathematical <span class="exturl"><a href="https://en.wikipedia.org/wiki/Mathematical_proof" target="_blank">demonstrations</a></span>. </p>
 <p>This system is valuable because it is independent from the theory studied. A theory is the set of axioms (acknowledged theorems) defining objects and their properties.</p>
</div>
<div class="pager" key="pager_logic_connector">
 <p>Logical connectors are fundamental elements for forming mathematical propositions from two propositions, whatever A and B are:</p>
 <ul>
  <li>implication, A implies B, noted "A ⇒ B"</li>
  <li>conjunction, A and B, noted "A ∧ B"</li>
  <li>disjunction, A or B, noted "A ∨ B"</li>
  <li>negation, not A, noted "¬ A"</li>
 </ul>
 <p>Each of these connectors is associated with two rules:</p>
 <ul>
  <li>a rule to justify (or demonstrate) the proposition: how can we justify "A ∧ B" ?</li>
  <li>a rule to deduce a new proposition: what can we deduce from "A ∧ B" ?</li>
 </ul>
</div>
<div class="pager" key="pager_logic_function">
 <p>A function f is a formula that has a value x, such that the proposition "y=f(x)" is a functional relation of x and y.</p>
</div>
<div class="pager" key="pager_logic_quantifier">
 <p>Mathematical propositions can also be formulae with variables taking on certain values: for example "3 is a prime number" can be considered as the formula "x is a prime number" where the variable "x" is replaced by "3".</p>
 <p> For a formula with a variable, we need to express that the proposition is true <span class="stress" style="font-size: 16px">for every</span> value the variable assumes, or that <span class="stress" style="font-size: 16px">there exists</span> at least one value for which the proposition is true. These new elements language are the quantifiers. </p>
</div>
<div class="pager" key="pager_logic_relation">
 <p>Relations, omnipresent in mathematics, are formulae that relate two values belonging to two, potentially different, universes. We talk about binary relation when the values belong to the same universe.</p>
 <p>The characterization of relations, as well as their properties, are presented.</p>
</div>
<div class="pager" key="pager_rewrite_seg">
 <p>Les réécritures permettent de déduire d’une égalité, une égalité presque identique dans laquelle un terme
  <!--{type="expr" input="a"}--> est remplacé par un terme
  <!--{type="expr" input="b"}-->, à condition que
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="a = b"}-->. Les réécritures de a en b sont données par le calcul algébrique :</p>
 <ul>
  <li>factorisation, développement</li>
  <li>idéntitiés remarquables</li>
  <li>simplifications</li> ...
 </ul>
 <p>Par exemple, on peut déduire de
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x=(2*(x-1))"}--> la proposition
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x= (2*x) - 2"}--> en remplaçant le terme
  <!--{type="expr" input="2*(x-1)"}--> par
  <!--{type="expr" input="minus (2*x) 2"}--> ; on sait en effet que
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="(2*(x-1)) = ((2*x)-2)"}--> par développement.</p>
</div>
<div class="pager" key="pager_set_operators">
 <p>A set E is a collection of objects that are called <span class="stress" style="font-size:16px">the elements</span> of E.</p>
 <p>The proposition that an element x belongs to E, or is an element of E, is noted <span class="stress" style="font-size:16px">
   <!--{type="prop" sci="true" input="sis_element x E"}--></span>. The negation of membership, ¬(
  <!--{type="prop" sci="true" input="sis_element x E"}-->), is noted <span class="stress" style="font-size:16px">
   <!--{type="prop" sci="true" input="~sis_element x E"}--></span>. </p>
 <p>A <span class="exturl"><a href="https://en.wikipedia.org/wiki/Set_(mathematics)" target="blank">set operator</a></span> allows us to construct one set from other sets.</p>
</div>
<div class="pager" key="pager_set_rewoperators">
 <p>Les calculs algébriques sur les ensembles ressemblent aux calculs sur les nombres parce que : </p>
 <ul>
  <li>les opérations ensemblistes (intersection, union, ...) ont des propriétés similaires aux opérations numériques (addition, multiplication, ...) : associativité, commutativité, distributivité, ... </li>
  <li>l'égalité ensembliste et l'égalité numérique sont des relations d'équivalence qui sont transitives, symétriques et réflexives (voir section suivante)</li>
 </ul>
 <p>L'algèbre ensembliste est équivalente à l'<span class="exturl"><a href="https://fr.wikipedia.org/wiki/Alg%C3%A8bre_de_Boole_(logique)" target="_blank">agèbre booléenne</a></span> : soit un élement appartient à un ensemble, soit il n'y appartient pas. Cette algèbre est centrale en informatique, dans l'écriture des programmes et dans l'élaboration des circuits électroniques. </p>
</div>
<div class="pager" key="pager_settheory">
 <a href="https://en.wikipedia.org/wiki/Georg_Cantor" target="_blank"><img class="txtwrap" src="./img/cantor.jpg" height="12%" width="12%"></a>
 <p> At the end of the 19<span class="sup">th</span> Century, the German mathematician <span class="exturl"><a href="https://en.wikipedia.org/wiki/Georg_Cantor" target="_blank">Georg Cantor</a></span> developed the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Set_theory" target="_blank">set theory</a></span>. This theory allows us to define fundamental elements of mathematics, notably integers, real numbers, functions ... </p>
 <p>In 1930, The Austro-Hungarian mathematician, <span class="exturl"><a href="https://en.wikipedia.org/wiki/Kurt_G%C3%B6del" target="_blank">Kurt Gödel</a></span> even demonstrated that any theory can be translated into the set theory. </p>
</div>
<div class="pager" key="pager_sigma_seg">
 <p>La notation sigma sert à faire la somme des termes d’une série de n nombres indéxés notés
  <!--{type="expr" input="app_series a i"}--> (avec l'indice i compris entre 1 et n typiquement). Cette somme se note :
  <!--{type="expr" style="vertical-align: -4px;" input="(sigma(k,1,n,(app_series a k)))"}-->.</p>
 <p>Dans cette notation, l'indice k est une variable muette : elle n'est pas déclarée dans le contexte et n'est valable que pour l'expression sommée.</p>
 <p>Les propriétés du sigma sont celles de l’addition (associativité, distributivité de la multiplication, …) et celles des changements d’écriture de l’indexation des nombres sommés.</p>
</div>
<div key="slide_demo_tuto_sigma_(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)">
 <!-- 	(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)
	by Backward select of select ( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2 (sigmasimpl)
 -->
 <div expr="(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))">
 <!-- 	((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))
	by Backward (elim_true_at_rank)
 -->
 <div expr="((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))
	by Section
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select (((n * (n + 1)) / 2 + n) + 1) (reducedenom)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select ((n + 2) * (n + 1)) / 2 (commutativity)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select (n * (n + 1) + 2 * (n + 1)) / 2 (factorize)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)
	by Forward lradd)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),(( sigma( k, zero, n, k)) + n) + 1 = ((n * (n + 1)) / 2 + n) + 1,sigmadef,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),(( sigma( k, zero, n, k)) + n) + 1 = ((n * (n + 1)) / 2 + n) + 1,sigmadef,0)
	by Forward select of select ((( sigma( k, zero, n, k)) + n) + 1) = ((n * (n + 1)) / 2 + n) + 1 (sigmadef)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),(( sigma( k, zero, n, k)) + n) + 1 = ((n * (n + 1)) / 2 + n) + 1,sigmadef,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))
	by Backward (red_true_at_rank)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)
	by Forward red_true_at_rank)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n))">
 <!-- 	((forall n : Nvar, true_at_rank P n))
	by Backward (ind_basic_forall)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_(true_at_rank P zero)">
 <!-- 	(true_at_rank P zero)
	by Backward (red_true_at_rank)
 -->
 <div expr="(true_at_rank P zero)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_logic_connector_tuto_01_(and B A)">
 <!-- 	(and B A)
	by Backward (conj)
 -->
 <div expr="(and B A)" class="pedagogic slide" exercise="logic_connector_tuto_01">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and A B,elim_conj_left,0)">
 <!--   (and A B,elim_conj_left,0)
  by Forward elim_conj_left)
 -->
 <div expr="(and A B,elim_conj_left,0)" class="pedagogic slide" exercise="logic_connector_tuto_02">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and A B,elim_conj_right,0)">
 <!--   (and A B,elim_conj_right,0)
  by Forward elim_conj_right)
 -->
 <div expr="(and A B,elim_conj_right,0)" class="pedagogic slide" exercise="logic_connector_tuto_02">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and B A)">
 <!--   (and B A)
  by Backward (conj)
 -->
 <div expr="(and B A)" class="pedagogic slide" exercise="logic_connector_tuto_02">
  <p>
   <!--<span class="light-bulb">ń</span>--> As in the previous example, the conjunction
   <!--{type="tag" input="s1"}--> is justified by invoking the rule <span class="buttontheo">by conjunction</span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_03_(or A B)">
 <!--   (or A B)
  by Backward (intro_or_right)
 -->
 <div expr="(or A B)" class="pedagogic slide" exercise="logic_connector_tuto_03">
  <p>
   <!--<span class="light-bulb">ń</span>--> The choice between using A and B to prove
   <!--{type="tag" input="s1"}--> <span class="buttontheo">by disjonction</span> is simple because only the proposition B is provided in hypothesis
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case P (or Q P))">
 <!--   (case P (or Q P))
  by Section
 -->
 <div expr="(case P (or Q P))" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p> Proving Q ∨ P when <span class="stress">P is true</span> requires creating a <span class="stress">logical scope</span> in which P is a hypothesis and Q ∨ P is a conclusion, with button <span class="buttonscope-wrapper"> <span class="buttonscope">↵</span></span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case P (or Q P),or Q P)">
 <!--   (case P (or Q P),or Q P)
  by Backward (intro_or_right)
 -->
 <div expr="(case P (or Q P),or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>--> Within this scope, we now find ourselves in exactly the same situation as in the previous exercise. The disjunction
   <!--{type="tag" input="s2_1"}--> is demonstrated by choosing P which is true by hypothesis
   <!--{type="tag" input="s2_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case Q (or Q P))">
 <!--   (case Q (or Q P))
  by Section
 -->
 <div expr="(case Q (or Q P))" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p> Proving Q ∨ P when <span class="stress">Q is true</span> requires creating a <span class="stress">logical scope</span> in which Q is a hypothesis and Q ∨ P is a conclusion, with button <span class="buttonscope-wrapper"> <span class="buttonscope">↵</span></span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case Q (or Q P),or Q P)">
 <!--   (case Q (or Q P),or Q P)
  by Backward (intro_or_left)
 -->
 <div expr="(case Q (or Q P),or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>--> Within this scope, we now find ourselves in exactly the same situation as in the previous exercise. The disjunction
   <!--{type="tag" input="s3_1"}--> is demonstrated by choosing P which is true by hypothesis
   <!--{type="tag" input="s3_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(or Q P)">
 <!--   (or Q P)
  by Backward (case_base)
 -->
 <div expr="(or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>-->Reasoning <span class="buttontheo">by disjunction of cases</span> can be used to justify a proposition when a disjunction is present. </p>
  <p>
   <!--{type="tag" input="s1"}--> is demonstrated with the help of the disjunction
   <!--{type="tag" input="s0"}--> by disjunction of cases. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(A -> (B -> and A B))">
 <!--   (A -> (B -> and A B))
  by Section
 -->
 <div expr="(A -> (B -> and A B))" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> The button
   <!--{type="button_section"}--> allows you to create the logical scope with A as assumption, and
   <!--{type="prop" input="(B -> (and A B))"}--> as conclusion. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(A -> (B -> and A B),B -> and A B)">
 <!--   (A -> (B -> and A B),B -> and A B)
  by Section
 -->
 <div expr="(A -> (B -> and A B),B -> and A B)" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> Again, the button
   <!--{type="button_section"}--> allows you to create the logical scope with A and B assumed and "A ∧ B" concluded. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(B -> and A B,A -> (B -> and A B),and A B)">
 <!--   (B -> and A B,A -> (B -> and A B),and A B)
  by Backward (conj)
 -->
 <div expr="(B -> and A B,A -> (B -> and A B),and A B)" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> We are now back at the first exercise of this tutorial (prove a conjunction).
   <!--{type="tag" input="s3_1"}--> is proved by conjunction with the help of hypotheses
   <!--{type="tag" input="s2_0"}--> and
   <!--{type="tag" input="s3_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_07_(B)">
 <!--   (B)
  by Backward (modus_ponens)
 -->
 <div expr="(B)" class="pedagogic slide" exercise="logic_connector_tuto_07">
  <p>
   <!--<span class="light-bulb">ń</span>--> B is deduced from the implication
   <!--{type="tag" input="s0"}--> if A is true. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_085_(A -> False,modus_ponens,0)">
 <!--   (A -> False,modus_ponens,0)
  by Forward modus_ponens)
 -->
 <div expr="(A -> False,modus_ponens,0)" class="pedagogic slide" exercise="logic_connector_tuto_085">
  <p>
   <!--<span class="light-bulb">ń</span>--> The <span class="stress">modus ponens</span> allows you to deduce False from
   <!--{type="tag" input="s3"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_085_(~ A,elim_negation,0)">
 <!--   (~ A,elim_negation,0)
  by Forward elim_negation)
 -->
 <div expr="(~ A,elim_negation,0)" class="pedagogic slide" exercise="logic_connector_tuto_085">
  <p>
   <!--<span class="light-bulb">ń</span>--> Translate the negation
   <!--{type="tag" input="s0"}--> into an implication, by definition of negation. </p>
  <p></p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False)">
 <!--   (A -> False)
  by Section
 -->
 <div expr="(A -> False)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> The button <span class="buttonscope-wrapper"><span class="buttonscope">↵</span></span> allows you to create a new scope in which A is an assumption. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False,B)">
 <!--   (A -> False,B)
  by Backward (modus_ponens)
 -->
 <div expr="(A -> False,B)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> The <span class="stress">modus ponens</span> allows you to justify B by implication
   <!--{type="tag" input="s0"}--> applied to assumption A. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False,False)">
 <!--   (A -> False,False)
  by Backward (modus_ponens)
 -->
 <div expr="(A -> False,False)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> The <span class="stress">modus ponens</span> allows you to justify False by implication
   <!--{type="tag" input="s2"}--> applied to assumption B. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(~ A)">
 <!--   (~ A)
  by Backward (elim_negation)
 -->
 <div expr="(~ A)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> Translate the negation
   <!--{type="tag" input="s0"}--> into an implication, by definition of negation. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_09_(A,intro_false,0)">
 <!--   (A,intro_false,0)
  by Forward intro_false)
 -->
 <div expr="(A,intro_false,0)" class="pedagogic slide" exercise="logic_connector_tuto_09">
  <p> Clicking on <span class="context">Context</span> shows statements from upper scopes.
   <!--<span class="light-bulb">ń</span>-->We find ourselves in exactly the same situation as in the previous exercise. It is possible to directly justify the contradiction
   <!--{type="tag" input="s3"}--> by invoking the principle of <span class="buttontheo">non-contradiction</span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_09_(B)">
 <!--   (B)
  by Backward (falseall)
 -->
 <div expr="(B)" class="pedagogic slide" exercise="logic_connector_tuto_09">
  <p>
   <!--<span class="light-bulb">ń</span>--> The clear contradiction of hypotheses
   <!--{type="tag" input="s0"}--> and
   <!--{type="tag" input="s2"}--> leads us to justify B with <span class="buttontheo">ex falso quodlibet</span> rule. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case (~ A) (or A B))">
 <!--   (case (~ A) (or A B))
  by Section
 -->
 <div expr="(case (~ A) (or A B))" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> When ¬ A is true, "A ∨ B" is demonstrated by choosing B, which is obtained by deduction from ¬ A with the help of
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case (~ A) (or A B),or A B)">
 <!--   (case (~ A) (or A B),or A B)
  by Backward (intro_or_right)
 -->
 <div expr="(case (~ A) (or A B),or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> When ¬ A is true, "A ∨ B" is demonstrated by choosing B, which is obtained by deduction from ¬ A with the help of
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case A (or A B))">
 <!--   (case A (or A B))
  by Section
 -->
 <div expr="(case A (or A B))" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> When A is true, "A ∨ B" is demonstrated by choosing A. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case A (or A B),or A B)">
 <!--   (case A (or A B),or A B)
  by Backward (intro_or_left)
 -->
 <div expr="(case A (or A B),or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> When A is true, "A ∨ B" is demonstrated by choosing A. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(or A B)">
 <!--   (or A B)
  by Backward (case_base_binary)
 -->
 <div expr="(or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> The use of <span class="buttontheo">excluded middle</span> allows us to demonstrate
   <!--{type="tag" input="s1"}--> : when A is true and when ¬ A is true. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(~ A -> B,modus_ponens,0)">
 <!--   (~ A -> B,modus_ponens,0)
  by Forward modus_ponens)
 -->
 <div expr="(~ A -> B,modus_ponens,0)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> We use
   <!--{type="tag" input="s0"}--> as a <span class="buttontheo">local theorem</span>to justify B. This justification acts as the modus ponens. The only difference is that a "local theorem" extends the modus ponens to expressions containing quantifiers like "for every ..." (see the following section). </p>
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))
	by Section
 -->
 <div expr="((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))">
 <!-- 	((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))
	by Section
 -->
 <div expr="((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))
	by Backward (ex_intro)
 -->
 <div expr="(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))">
 <!-- 	(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))
	by Backward (intro_or_left)
 -->
 <div expr="(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)">
 <!-- 	((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)
	by Forward ex_elim)
 -->
 <div expr="((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))
	by Section
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))
	by Backward (ex_intro)
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (intro_or_left)
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))
	by Section
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))
	by Backward (ex_intro)
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (intro_or_right)
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (case_base)
 -->
 <div expr="(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))
	by Section
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))
	by Backward (conj)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)
	by Forward elim_conj_left)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)
	by Forward elim_conj_right)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U A x))">
 <!-- 	((forall x : O1U, app_prop O1U A x))
	by Section
 -->
 <div expr="((forall x : O1U, app_prop O1U A x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)">
 <!-- 	((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)
	by Forward elim_conj_left)
 -->
 <div expr="((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U B x))">
 <!-- 	((forall x : O1U, app_prop O1U B x))
	by Section
 -->
 <div expr="((forall x : O1U, app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)">
 <!-- 	((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)
	by Forward elim_conj_right)
 -->
 <div expr="((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))
	by Backward (conj)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="text_Antonym1">
 <!--TODO-->
</div>
<div key="text_Antonym2">
 <!--TODO-->
</div>
<div key="text_Superlative1">
 <!--TODO-->
</div>
<div key="text_Superlative2">
 <!--TODO-->
</div>
<div key="text_adabsurdium">
 <!--TODO-->
</div>
<div key="text_addsub">
 <!--TODO-->
</div>
<div key="text_app_def">
 <!--TODO-->
</div>
<div key="text_app_sqrt">
 <!--TODO-->
</div>
<div key="text_app_sqrt_bounded">
 <!--TODO-->
</div>
<div key="text_app_square">
 <!--TODO-->
</div>
<div key="text_app_square_bounded">
 <!--TODO-->
</div>
<div key="text_appdef"></div>
<div key="text_apply_forall">
 <!--TODO-->
</div>
<div key="text_apply_fun_lr">
 <!--TODO-->
</div>
<div key="text_apply_ineq_inverse">
 <!--TODO-->
</div>
<div key="text_apply_ineq_sqrt">
 <!--TODO-->
</div>
<div key="text_apply_ineq_square">
 <!--TODO-->
</div>
<div key="text_arith_def">
 <!--TODO-->
</div>
<div key="text_arith_pro">
 <!--TODO-->
</div>
<div key="text_arith_series">
 <!--TODO-->
</div>
<div key="text_ax_bad">
 <!--TODO-->
</div>
<div key="text_ax_good">
 <!--TODO-->
</div>
<div key="text_back_elim_equiv">
 <!--TODO-->
</div>
<div key="text_binrel"></div>
<div key="text_bound_conj">
 <!--TODO-->
</div>
<div key="text_bound_to_eq">
 <!--TODO-->
</div>
<div key="text_bounded_elim">
 <!--TODO-->
</div>
<div key="text_case_base">
 <!--TODO-->
</div>
<div key="text_case_base_binary">
 <!--TODO-->
</div>
<div key="text_case_good_or_bad">
 <!--TODO-->
</div>
<div key="text_comb_comp_lt">
 <!--TODO-->
</div>
<div key="text_combadd">
 <!--TODO-->
</div>
<div key="text_combinaison"></div>
<div key="text_combine_cmp_minus">
 <!--TODO-->
</div>
<div key="text_combine_cmp_plus">
 <!--TODO-->
</div>
<div key="text_combsub">
 <!--TODO-->
</div>
<div key="text_commutativity">
 <!--TODO-->
</div>
<div key="text_conj">
 <!--TODO-->
</div>
<div key="text_conjunction">
 <p>Text in english</p>
</div>
<div key="text_converge">
 <!--TODO-->
</div>
<div key="text_deduce_not_color">
 <!--TODO-->
</div>
<div key="text_def_fbij">
 <!--TODO-->
</div>
<div key="text_def_fcomp">
 <!--TODO-->
</div>
<div key="text_def_finj">
 <!--TODO-->
</div>
<div key="text_def_finvol">
 <!--TODO-->
</div>
<div key="text_def_fsurj">
 <!--TODO-->
</div>
<div key="text_def_rantisym">
 <!--TODO-->
</div>
<div key="text_def_rcomp">
 <!--TODO-->
</div>
<div key="text_def_rfun">
 <!--TODO-->
</div>
<div key="text_def_rident">
 <!--TODO-->
</div>
<div key="text_def_rinj">
 <!--TODO-->
</div>
<div key="text_def_rinv">
 <!--TODO-->
</div>
<div key="text_def_rrefl">
 <!--TODO-->
</div>
<div key="text_def_rsurj">
 <!--TODO-->
</div>
<div key="text_def_rsym">
 <!--TODO-->
</div>
<div key="text_def_rtotleft">
 <!--TODO-->
</div>
<div key="text_def_rtrans">
 <!--TODO-->
</div>
<div key="text_disjonction"></div>
<div key="text_distrib"></div>
<div key="text_elim_comp">
 <!--TODO-->
</div>
<div key="text_elim_conj_left">
 <!--TODO-->
</div>
<div key="text_elim_conj_right">
 <!--TODO-->
</div>
<div key="text_elim_eqfun">
 <!--TODO-->
</div>
<div key="text_elim_eqset">
 <!--TODO-->
</div>
<div key="text_elim_even_def">
 <!--TODO-->
</div>
<div key="text_elim_false_exset">
 <!--TODO-->
</div>
<div key="text_elim_gen_app_rel">
 <!--TODO-->
</div>
<div key="text_elim_has_finite_limit_decr">
 <!--TODO-->
</div>
<div key="text_elim_has_finite_limit_incr">
 <!--TODO-->
</div>
<div key="text_elim_is_elem_universe">
 <!--TODO-->
</div>
<div key="text_elim_multiple">
 <!--TODO-->
</div>
<div key="text_elim_negation">
 <!--TODO-->
</div>
<div key="text_elim_pprod">
 <!--TODO-->
</div>
<div key="text_elim_requiv">
 <!--TODO-->
</div>
<div key="text_elim_scomp">
 <!--TODO-->
</div>
<div key="text_elim_sdiff">
 <!--TODO-->
</div>
<div key="text_elim_sequiv">
 <!--TODO-->
</div>
<div key="text_elim_set_lteq">
 <!--TODO-->
</div>
<div key="text_elim_shas_lower_bound">
 <!--TODO-->
</div>
<div key="text_elim_shas_upper_bound">
 <!--TODO-->
</div>
<div key="text_elim_sinter">
 <!--TODO-->
</div>
<div key="text_elim_sis_decreasing">
 <!--TODO-->
</div>
<div key="text_elim_sis_gt_zero">
 <!--TODO-->
</div>
<div key="text_elim_sis_increasing">
 <!--TODO-->
</div>
<div key="text_elim_sis_lt_zero">
 <!--TODO-->
</div>
<div key="text_elim_subset">
 <!--TODO-->
</div>
<div key="text_elim_sunion">
 <!--TODO-->
</div>
<div key="text_elim_true_at_rank">
 <!--TODO-->
</div>
<div key="text_eq_inverse">
 <!--TODO-->
</div>
<div key="text_eq_reverse">
 <!--TODO-->
</div>
<div key="text_eq_symmetry">
 <!--TODO-->
</div>
<div key="text_eq_trans">
 <!--TODO-->
</div>
<div key="text_eqfun">
 <!--TODO-->
</div>
<div key="text_eqrel"></div>
<div key="text_eqset"></div>
<div key="text_equiv"></div>
<div key="text_equiv_rtrans">
 <!--TODO-->
</div>
<div key="text_ex_elim">
 <!--TODO-->
</div>
<div key="text_ex_intro">
 <!--TODO-->
</div>
<div key="text_exists"></div>
<div key="text_expand">
 <!--TODO-->
</div>
<div key="text_fact">
 <!--TODO-->
</div>
<div key="text_factorize">
 <!--TODO-->
</div>
<div key="text_falseall">
 <!--TODO-->
</div>
<div key="text_forall"></div>
<div key="text_funop">
 <!--TODO-->
</div>
<div key="text_gen_factorize">
 <!--TODO-->
</div>
<div key="text_geo_def">
 <!--TODO-->
</div>
<div key="text_geo_pro">
 <!--TODO-->
</div>
<div key="text_geo_series">
 <!--TODO-->
</div>
<div key="text_implication"></div>
<div key="text_inclusionsimpl">
 <!--TODO-->
</div>
<div key="text_ind_basic_forall">
 <!--TODO-->
</div>
<div key="text_ind_init">
 <!--TODO-->
</div>
<div key="text_induction"></div>
<div key="text_ineq_sym_rew">
 <!--TODO-->
</div>
<div key="text_ineqapp"></div>
<div key="text_ineqbound"></div>
<div key="text_ineqcomb"></div>
<div key="text_ineqconv">
 <!--TODO-->
</div>
<div key="text_ineqrel"></div>
<div key="text_intro_false">
 <!--TODO-->
</div>
<div key="text_intro_or_left">
 <!--TODO-->
</div>
<div key="text_intro_or_right">
 <!--TODO-->
</div>
<div key="text_intro_sqrt_square">
 <!--TODO-->
</div>
<div key="text_leftright"></div>
<div key="text_leftright_ineq"></div>
<div key="text_leftright_neq"></div>
<div key="text_limfinite">
 <!--TODO-->
</div>
<div key="text_limit_finite">
 <!--TODO-->
</div>
<div key="text_limit_inf">
 <!--TODO-->
</div>
<div key="text_limit_neg_inf">
 <!--TODO-->
</div>
<div key="text_limitinf">
 <!--TODO-->
</div>
<div key="text_limitops">
 <!--TODO-->
</div>
<div key="text_linearsimpl">
 <!--TODO-->
</div>
<div key="text_logicothers"></div>
<div key="text_lradd">
 <!--TODO-->
</div>
<div key="text_lradd_bounded">
 <!--TODO-->
</div>
<div key="text_lradd_ineq">
 <!--TODO-->
</div>
<div key="text_lradd_neq">
 <!--TODO-->
</div>
<div key="text_lrapply"></div>
<div key="text_lrdiv">
 <!--TODO-->
</div>
<div key="text_lrdiv_bounded">
 <!--TODO-->
</div>
<div key="text_lrdiv_ineq">
 <!--TODO-->
</div>
<div key="text_lrdiv_neq">
 <!--TODO-->
</div>
<div key="text_lrmul">
 <!--TODO-->
</div>
<div key="text_lrmul_bounded">
 <!--TODO-->
</div>
<div key="text_lrmul_ineq">
 <!--TODO-->
</div>
<div key="text_lrmul_neq">
 <!--TODO-->
</div>
<div key="text_lrsub">
 <!--TODO-->
</div>
<div key="text_lrsub_bounded">
 <!--TODO-->
</div>
<div key="text_lrsub_ineq">
 <!--TODO-->
</div>
<div key="text_lrsub_neq">
 <!--TODO-->
</div>
<div key="text_lt_next_int">
 <!--TODO-->
</div>
<div key="text_modus_ponens">
 <!--TODO-->
</div>
<div key="text_muldiv">
 <!--TODO-->
</div>
<div key="text_multiple">
 <!--TODO-->
</div>
<div key="text_negation"></div>
<div key="text_neq_symmetry">
 <!--TODO-->
</div>
<div key="text_non_zero_gt">
 <!--TODO-->
</div>
<div key="text_non_zero_lt">
 <!--TODO-->
</div>
<div key="text_oldest">
 <!--TODO-->
</div>
<div key="text_polysquare">
 <!--TODO-->
</div>
<div key="text_prod">
 <!--TODO-->
</div>
<div key="text_proddecompl">
 <!--TODO-->
</div>
<div key="text_proddef">
 <!--TODO-->
</div>
<div key="text_prodidx">
 <!--TODO-->
</div>
<div key="text_prodinverse">
 <!--TODO-->
</div>
<div key="text_prodlinear">
 <!--TODO-->
</div>
<div key="text_prodrem">
 <!--TODO-->
</div>
<div key="text_prodresult1">
 <!--TODO-->
</div>
<div key="text_prodsimpl">
 <!--TODO-->
</div>
<div key="text_produpshift">
 <!--TODO-->
</div>
<div key="text_reason_capacity">
 <!--TODO-->
</div>
<div key="text_red_true_at_rank">
 <!--TODO-->
</div>
<div key="text_reducedenom">
 <!--TODO-->
</div>
<div key="text_relops"></div>
<div key="text_relothers"></div>
<div key="text_relprop"></div>
<div key="text_relset">
 <!--TODO-->
</div>
<div key="text_remid"></div>
<div key="text_rewops"></div>
<div key="text_rewprops">
 <!--TODO-->
</div>
<div key="text_rewriting">
 <!--TODO-->
</div>
<div key="text_sandwich">
 <!--TODO-->
</div>
<div key="text_section">
 <!--TODO-->
</div>
<div key="text_series_limitation">
 <!--TODO-->
</div>
<div key="text_series_sign">
 <!--TODO-->
</div>
<div key="text_series_variation">
 <!--TODO-->
</div>
<div key="text_set_absorb">
 <!--TODO-->
</div>
<div key="text_set_adabsurdum">
 <!--TODO-->
</div>
<div key="text_set_comb">
 <!--TODO-->
</div>
<div key="text_set_demorgan">
 <!--TODO-->
</div>
<div key="text_set_eq_symmetry">
 <!--TODO-->
</div>
<div key="text_set_eq_trans">
 <!--TODO-->
</div>
<div key="text_set_excluded">
 <!--TODO-->
</div>
<div key="text_set_inter_comb">
 <!--TODO-->
</div>
<div key="text_set_lteq_transitivity">
 <!--TODO-->
</div>
<div key="text_set_neutral">
 <!--TODO-->
</div>
<div key="text_set_rewriting"></div>
<div key="text_set_union_comb">
 <!--TODO-->
</div>
<div key="text_setassociative">
 <!--TODO-->
</div>
<div key="text_setcommutative">
 <!--TODO-->
</div>
<div key="text_setdevelopp">
 <!--TODO-->
</div>
<div key="text_setexpr">
 <!--TODO-->
</div>
<div key="text_setfactorize">
 <!--TODO-->
</div>
<div key="text_setfun"></div>
<div key="text_setgraph"></div>
<div key="text_setops"></div>
<div key="text_sigma"></div>
<div key="text_sigmadecompl">
 <!--TODO-->
</div>
<div key="text_sigmadef">
 <!--TODO-->
</div>
<div key="text_sigmaidx">
 <!--TODO-->
</div>
<div key="text_sigmainverse">
 <!--TODO-->
</div>
<div key="text_sigmalinear">
 <!--TODO-->
</div>
<div key="text_sigmarem"></div>
<div key="text_sigmaresult1">
 <!--TODO-->
</div>
<div key="text_sigmaresult2">
 <!--TODO-->
</div>
<div key="text_sigmaresult3">
 <!--TODO-->
</div>
<div key="text_sigmasimpl">
 <!--TODO-->
</div>
<div key="text_sigmaupshift">
 <!--TODO-->
</div>
<div key="text_simpl"></div>
<div key="text_slim_def_elim">
 <!--TODO-->
</div>
<div key="text_slim_inf_def_elim">
 <!--TODO-->
</div>
<div key="text_slimfinite_inf_elim">
 <!--TODO-->
</div>
<div key="text_slteq"></div>
<div key="text_somesets"></div>
<div key="text_sophiehattheory"></div>
<div key="text_square_diff">
 <!--TODO-->
</div>
<div key="text_subadd">
 <!--TODO-->
</div>
<div key="text_trans_lt_gt">
 <!--TODO-->
</div>
<div key="text_true_at_rank">
 <!--TODO-->
</div>
<div key="text_truthlie">
 <!--TODO-->
</div>
<div key="text_updownsimpl">
 <!--TODO-->
</div>
<div key="text_varchange">
 <!--TODO-->
</div>
<div key="text_youngest">
 <!--TODO-->
</div>
